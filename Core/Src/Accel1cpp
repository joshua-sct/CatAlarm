#include <Accel.hpp>
#include "stm32g0xx_hal.h"
#include "usart.h"
#include "gpio.h"
#include "i2c.h"
#include "tim.h"
#include "usart.h"
#include "gpio.h"
#define BOOT_TIME 20
#include "lis2dw12_reg.h"
#include <string.h>
#include <stdio.h>

Accel::Accel(I2C_HandleTypeDef *i2c_handle) {
    dev_ctx.write_reg = platform_write;
    dev_ctx.read_reg = platform_read;
    dev_ctx.mdelay = platform_delay;
    dev_ctx.handle = (void *)i2c_handle;

//    platform_init();
//    platform_delay(20); // Wait for sensor boot time
//    HAL_Delay(20);
    // Check device ID
    uint8_t whoamI;
    lis2dw12_device_id_get(&dev_ctx, &whoamI);
    while (whoamI != LIS2DW12_ID) {
        lis2dw12_device_id_get(&dev_ctx, &whoamI);
        // Handle device not found error
    }

    // Configure the sensor
    lis2dw12_reset_set(&dev_ctx, PROPERTY_ENABLE);
    lis2dw12_block_data_update_set(&dev_ctx, PROPERTY_ENABLE);
    lis2dw12_full_scale_set(&dev_ctx, LIS2DW12_2g);
    lis2dw12_filter_path_set(&dev_ctx, LIS2DW12_LPF_ON_OUT);
    lis2dw12_filter_bandwidth_set(&dev_ctx, LIS2DW12_ODR_DIV_4);
    lis2dw12_power_mode_set(&dev_ctx, LIS2DW12_HIGH_PERFORMANCE);
    lis2dw12_data_rate_set(&dev_ctx, LIS2DW12_XL_ODR_25Hz);
}

void Accel::readDataPolling() {
    uint8_t reg;
    lis2dw12_flag_data_ready_get(&dev_ctx, &reg);

    if (reg) {
        memset(data_raw_acceleration, 0x00, 3 * sizeof(int16_t));
        lis2dw12_acceleration_raw_get(&dev_ctx, data_raw_acceleration);

        acceleration_mg[0] = lis2dw12_from_fs2_to_mg(data_raw_acceleration[0]);
        acceleration_mg[1] = lis2dw12_from_fs2_to_mg(data_raw_acceleration[1]);
        acceleration_mg[2] = lis2dw12_from_fs2_to_mg(data_raw_acceleration[2]);
    }
}

float Accel::getAccelerationX() {
    return acceleration_mg[0];
}

float Accel::getAccelerationY() {
    return acceleration_mg[1];
}

float Accel::getAccelerationZ() {
    return acceleration_mg[2];
}

static int32_t platform_write(void *handle, uint8_t reg, const uint8_t *bufp,
                              uint16_t len)
{
  HAL_I2C_Mem_Write((I2C_HandleTypeDef *)handle, LIS2DW12_I2C_ADD_L, reg,
                    I2C_MEMADD_SIZE_8BIT, (uint8_t*) bufp, len, 1000);
  return 0;
}

/*
 * @brief  Read generic device register (platform dependent)
 *
 * @param  handle    customizable argument. In this examples is used in
 *                   order to select the correct sensor bus handler.
 * @param  reg       register to read
 * @param  bufp      pointer to buffer that store the data read
 * @param  len       number of consecutive register to read
 *
 */
static int32_t platform_read(void *handle, uint8_t reg, uint8_t *bufp,
                             uint16_t len)
{
  HAL_I2C_Mem_Read((I2C_HandleTypeDef *)handle, LIS2DW12_I2C_ADD_L, reg,
                   I2C_MEMADD_SIZE_8BIT, bufp, len, 1000);
  return 0;
}

/*
 * @brief  Write generic device register (platform dependent)
 *
 * @param  tx_buffer     buffer to transmit
 * @param  len           number of byte to send
 *
 */
static void tx_com(uint8_t *tx_buffer, uint16_t len)
{
  HAL_UART_Transmit(&huart2, tx_buffer, len, 1000);
}

/*
 * @brief  platform specific delay (platform dependent)
 *
 * @param  ms        delay in ms
 *
 */
static void platform_delay(uint32_t ms)
{
  HAL_Delay(ms);
}

/*
 * @brief  platform specific initialization (platform dependent)
 */
static void platform_init(void)
{
}
