#include <Accel.hpp>
#include "stm32g0xx_hal.h"
#include "usart.h"
#include "gpio.h"
#include "i2c.h"
#define SENSOR_BUS hi2c2
#define BOOT_TIME 20

Accel::Accel() {
    dev_ctx.write_reg = platform_write;
    dev_ctx.read_reg = platform_read;
    dev_ctx.mdelay = platform_delay;
    dev_ctx.handle = &SENSOR_BUS;

//    platform_init();
//    platform_delay(BOOT_TIME);

    lis2dw12_device_id_get(&dev_ctx, &whoamI);

    if (whoamI != LIS2DW12_ID) {
        while (1) {
            /* Gérer ici le cas où le périphérique n'est pas trouvé */
        }
    }

    /* Restore default configuration */
    lis2dw12_reset_set(&dev_ctx, PROPERTY_ENABLE);

    do {
      lis2dw12_reset_get(&dev_ctx, &rst);
    } while (rst);

    /* Enable Block Data Update */
    lis2dw12_block_data_update_set(&dev_ctx, PROPERTY_ENABLE);
    /* Set full scale */
    //lis2dw12_full_scale_set(&dev_ctx, LIS2DW12_8g);
    lis2dw12_full_scale_set(&dev_ctx, LIS2DW12_2g);
    /* Configure filtering chain
     * Accelerometer - filter path / bandwidth
     */
    lis2dw12_filter_path_set(&dev_ctx, LIS2DW12_LPF_ON_OUT);
    lis2dw12_filter_bandwidth_set(&dev_ctx, LIS2DW12_ODR_DIV_4);
    /* Configure power mode */
    lis2dw12_power_mode_set(&dev_ctx, LIS2DW12_HIGH_PERFORMANCE);
    //lis2dw12_power_mode_set(&dev_ctx, LIS2DW12_CONT_LOW_PWR_LOW_NOISE_12bit);
    /* Set Output Data Rate */
    lis2dw12_data_rate_set(&dev_ctx, LIS2DW12_XL_ODR_25Hz);
}

void Accel::readDataPolling() {
	  while (1) {
	    uint8_t reg;
	    /* Read output only if new value is available */
	    lis2dw12_flag_data_ready_get(&dev_ctx, &reg);

	    if (reg) {
	      /* Read acceleration data */
	      memset(data_raw_acceleration, 0x00, 3 * sizeof(int16_t));
	      lis2dw12_acceleration_raw_get(&dev_ctx, data_raw_acceleration);
	      //acceleration_mg[0] = lis2dw12_from_fs8_lp1_to_mg(data_raw_acceleration[0]);
	      //acceleration_mg[1] = lis2dw12_from_fs8_lp1_to_mg(data_raw_acceleration[1]);
	      //acceleration_mg[2] = lis2dw12_from_fs8_lp1_to_mg(data_raw_acceleration[2]);
	      acceleration_mg[0] = lis2dw12_from_fs2_to_mg(
	                             data_raw_acceleration[0]);
	      acceleration_mg[1] = lis2dw12_from_fs2_to_mg(
	                             data_raw_acceleration[1]);
	      acceleration_mg[2] = lis2dw12_from_fs2_to_mg(
	                             data_raw_acceleration[2]);
	    }
    }
}

static int32_t platform_write(void *handle, uint8_t reg, const uint8_t *bufp,
                              uint16_t len)
{
  HAL_I2C_Mem_Write((I2C_HandleTypeDef*)handle, LIS2DW12_I2C_ADD_L, reg, I2C_MEMADD_SIZE_8BIT, (uint8_t*) bufp, len, 1000);
  return 0;
}

static int32_t platform_read(void *handle, uint8_t reg, uint8_t *bufp,
                             uint16_t len)
{
  HAL_I2C_Mem_Read((I2C_HandleTypeDef*)handle, LIS2DW12_I2C_ADD_L, reg, I2C_MEMADD_SIZE_8BIT, bufp, len, 1000);
  return 0;
}

void Accel::tx_com(uint8_t *tx_buffer, uint16_t len) {
    HAL_UART_Transmit(&huart2, tx_buffer, len, 1000);
}

void Accel::platform_delay(uint32_t ms) {
    HAL_Delay(ms);
}

void Accel::platform_init(void) {
    // Initialisation de la plateforme spécifique
}
